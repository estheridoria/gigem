ciMult <- qt(0.95 / 2 + .5, datac$n - 1)
datac$ci <- datac$se * ciMult
# 3. Ensure data.table class and perform renaming
# Set to data.table if it isn't already (important for efficiency/merging in statsSummary)
data.table::setDT(datac)
# Dynamic Renaming
old_names <- c("mean", "sd", "se", "ci")
new_names <- c(paste(group, "mean", sep = "_"),
paste(group, "sd", sep = "_"),
paste(group, "se", sep = "_"),
paste(group, "ci", sep = "_"))
# Use data.table::setnames for efficient, in-place renaming
data.table::setnames(datac, old_names, new_names, skip_absent = TRUE)
# Merge summary statistics into a common table
if (n_col) {
# Merge on all group variables plus n (n should be the same across all metrics for a given group)
summary_norm_common <- merge(
summary_norm_common,
summary_group,
by = c(group_vars, "n"), # The dynamically-named columns (e.g., Sleep_Time_L_mean) will be added
all = TRUE # Ensure all groups are kept even if a metric is NA for some
)
} else {
# First pass: Set the common table and update flag
summary_norm_common <- summary_group
n_col <- TRUE
}
}
# Initialize a flag to track the first pass
n_col <- FALSE
summary_norm_common <- data.table::data.table() # Initialize as an empty data.table
# Loop through each group to compute summary statistics
for (group in groups) {
# Compute summary statistics for the current group using the dynamically-named summarySE
# length2 <- function(x, na.rm = FALSE) {
#   if (FALSE) sum(!is.na(x)) else length(x)
# }
# 1. Calculate basic statistics
# Use plyr::ddply, which is fine, but may return a data.frame or tibble.
datac <- plyr::ddply(dt, group_vars, .drop = TRUE, .fun = function(xx, col) {
c(n = length(xx[[col]]),
mean = mean(xx[[col]], na.rm = F),
sd = sd(xx[[col]], na.rm = F))
}, group)
# 2. Add standard error and confidence interval
datac$se <- datac$sd / sqrt(datac$n)  # Standard error
# Critical value (t-score)
ciMult <- qt(0.95 / 2 + .5, datac$n - 1)
datac$ci <- datac$se * ciMult
# 3. Ensure data.table class and perform renaming
# Set to data.table if it isn't already (important for efficiency/merging in statsSummary)
data.table::setDT(datac)
# Dynamic Renaming
old_names <- c("mean", "sd", "se", "ci")
new_names <- c(paste(group, "mean", sep = "_"),
paste(group, "sd", sep = "_"),
paste(group, "se", sep = "_"),
paste(group, "ci", sep = "_"))
# Use data.table::setnames for efficient, in-place renaming
data.table::setnames(datac, old_names, new_names, skip_absent = TRUE)
# Merge summary statistics into a common table
if (n_col) {
# Merge on all group variables plus n (n should be the same across all metrics for a given group)
summary_norm_common <- merge(
summary_norm_common,
summary_group,
by = c(group_vars, "n"), # The dynamically-named columns (e.g., Sleep_Time_L_mean) will be added
all = TRUE # Ensure all groups are kept even if a metric is NA for some
)
} else {
# First pass: Set the common table and update flag
summary_norm_common <- summary_group
n_col <- TRUE
}
}
n_col
source("~/GitHub/gigem/R/statsSummary.R")
# Define all grouping variables consistently
group_vars <- c("Sex", "Genotype", "Temperature", "Treatment","Environment","Light", "Batch")
# Initialize a flag to track the first pass
n_col <- FALSE
summary_norm_common <- data.table::data.table() # Initialize as an empty data.table
group
# 1. Calculate basic statistics
# Use plyr::ddply, which is fine, but may return a data.frame or tibble.
datac <- plyr::ddply(dt, group_vars, .drop = TRUE, .fun = function(xx, col) {
c(n = length(xx[[col]]),
mean = mean(xx[[col]], na.rm = F),
sd = sd(xx[[col]], na.rm = F))
}, group)
# 2. Add standard error and confidence interval
datac$se <- datac$sd / sqrt(datac$n)  # Standard error
# Critical value (t-score)
ciMult <- qt(0.95 / 2 + .5, datac$n - 1)
datac$ci <- datac$se * ciMult
# 3. Ensure data.table class and perform renaming
# Set to data.table if it isn't already (important for efficiency/merging in statsSummary)
data.table::setDT(datac)
# Dynamic Renaming
old_names <- c("mean", "sd", "se", "ci")
new_names <- c(paste(group, "mean", sep = "_"),
paste(group, "sd", sep = "_"),
paste(group, "se", sep = "_"),
paste(group, "ci", sep = "_"))
# Use data.table::setnames for efficient, in-place renaming
data.table::setnames(datac, old_names, new_names, skip_absent = TRUE)
# Merge summary statistics into a common table
if (n_col) {
# Merge on all group variables plus n (n should be the same across all metrics for a given group)
summary_norm_common <- merge(
summary_norm_common,
datac,
by = c(group_vars, "n"), # The dynamically-named columns (e.g., Sleep_Time_L_mean) will be added
all = TRUE # Ensure all groups are kept even if a metric is NA for some
)
} else {
# First pass: Set the common table and update flag
summary_norm_common <- datac
n_col <- TRUE
}
#' This function calculates summary statistics for specified groups using the `summarySE` function and writes
#' the results to a CSV file.
#'
#' @param ExperimentData An S4 object containing experimental data, including a `Batch` attribute.
#' @param dt A data.table containing raw summary statistics to be processed.
#' @param groups A character vector specifying the groups for which to calculate summary statistics.
#' @param norm_factor A character string indicating the factor used for normalization.
#'
#' @return A data.table containing the summary statistics, which is also saved as a CSV file.
#' @keywords internal
statsSummary <- function(ExperimentData, dt, groups, norm_factor) {
# Define all grouping variables consistently
group_vars <- c("Sex", "Genotype", "Temperature", "Treatment","Environment","Light", "Batch")
# Initialize a flag to track the first pass
n_col <- FALSE
summary_norm_common <- data.table::data.table() # Initialize as an empty data.table
# Loop through each group to compute summary statistics
for (group in groups) {
# Compute summary statistics for the current group using the dynamically-named summarySE
# length2 <- function(x, na.rm = FALSE) {
#   if (FALSE) sum(!is.na(x)) else length(x)
# }
# 1. Calculate basic statistics
# Use plyr::ddply, which is fine, but may return a data.frame or tibble.
datac <- plyr::ddply(dt, group_vars, .drop = TRUE, .fun = function(xx, col) {
c(n = length(xx[[col]]),
mean = mean(xx[[col]], na.rm = F),
sd = sd(xx[[col]], na.rm = F))
}, group)
# 2. Add standard error and confidence interval
datac$se <- datac$sd / sqrt(datac$n)  # Standard error
# Critical value (t-score)
ciMult <- qt(0.95 / 2 + .5, datac$n - 1)
datac$ci <- datac$se * ciMult
# 3. Ensure data.table class and perform renaming
# Set to data.table if it isn't already (important for efficiency/merging in statsSummary)
data.table::setDT(datac)
# Dynamic Renaming
old_names <- c("mean", "sd", "se", "ci")
new_names <- c(paste(group, "mean", sep = "_"),
paste(group, "sd", sep = "_"),
paste(group, "se", sep = "_"),
paste(group, "ci", sep = "_"))
# Use data.table::setnames for efficient, in-place renaming
data.table::setnames(datac, old_names, new_names, skip_absent = TRUE)
# Merge summary statistics into a common table
if (n_col) {
# Merge on all group variables plus n (n should be the same across all metrics for a given group)
summary_norm_common <- merge(
summary_norm_common,
datac,
by = c(group_vars, "n"), # The dynamically-named columns (e.g., Sleep_Time_L_mean) will be added
all = TRUE # Ensure all groups are kept even if a metric is NA for some
)
} else {
# First pass: Set the common table and update flag
summary_norm_common <- datac
n_col <- TRUE
}
}
# Write the summary data table to a CSV file
data.table::fwrite(summary_norm_common, paste0("stat_summary_", ExperimentData@Batch, ".csv"))
# Return the generated data table
return(summary_norm_common)
}
source("~/GitHub/gigem/R/statsSummary.R")
# Summary of statistics for sleep time for all groups
stat_summary <- statsSummary(ExperimentData, dt_finalSummary, groups, norm_factor)
# Source each R file (run info)
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# Get the list of R files in the directory
r_files <- list.files(getwd(), pattern = "^Main[0-9_a-zA-Z]*\\.R$", full.names = TRUE)
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
incodeinfo
rm(incodeinfo)
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
View(incodeinfo)
#' @param plotSelection A character string specifying if the user wants all possible plots, no optional plots, or select specific plot outputs.
#' @param font A string variable determining the font style of the produced plots.
#' @param pValues A TRUE/FALSE vector for if combined plots will display p values for 2-condition overlays.
#' @export
#'
#' @return This function does not return a value but performs a series of steps to process the data,
#' generate plots, and calculate statistics.
#'
#'
#' @keywords export
runOneBatch <- function(oneBatch, numDays,
overlayVar = c("Treatment", "Sex", "Genotype", "Temperature", "Environment", "Light"),
rowVar = c("Genotype", "Sex", "Temperature", "Treatment", "Environment", "Light"),
columnVar = c("Environment", "Sex", "Genotype", "Temperature", "Treatment", "Light"),
plotSelection = c("All", "None", "Select"),
font = c("plain", "bold", "italic", "bold.italic"),
pValues = c(FALSE, TRUE)) {
# Warnings/Errors-------------------------------------------------------------
if (missing(oneBatch)){
stop("'oneBatch' must be specified")
}
all_dirs <- list.dirs(getwd(), full.names = FALSE, recursive = FALSE)
if (length(grep(oneBatch, all_dirs)) != 1){
stop("The 'oneBatch' specified is not a subdirectory inside the current working directory. Please make sure your current directory is correct.")
}
if (missing(numDays) || !is.numeric(numDays)){
stop("'numDays' must be specified as a whole number.")
}
if(length(unique(c(overlayVar, rowVar, columnVar))) < 3){  # divisions for fascetting plots
stop("'overlayVar', rowVar, and columnVar cannot contain the same variable names.")
}
divisions<- character()
divisions[1]<- match.arg(overlayVar)
divisions[2]<- match.arg(rowVar)
divisions[3]<- match.arg(columnVar)
plotSelection <- match.arg(plotSelection)
#divisions<- c(overlayVar, rowVar, columnVar)
font<- match.arg(font)
if(!is.logical(pValues)){
stop("'pValues' must be either 'TRUE' or 'FALSE'")
}
# Set the stage---------------------------------------------------------------
# Save the current working directory
original_wd <- getwd()
# Change to the target directory
setwd(paste0(original_wd, "/", oneBatch))
# Get the list of R files in the directory
r_files <- list.files(getwd(), pattern = "^Main[0-9_a-zA-Z]*\\.R$", full.names = TRUE)
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
}
# add "monitor" to the info file
incodeinfo[["monitor"]]<- paste0("M", gsub("\\D", "", incodeinfo$file))
#change any NA values to "NA" to prevent errors
incodeinfo[is.na(incodeinfo)] <- "NA"
incodeinfo[,6:11]<- lapply(incodeinfo[,6:11], as.character)
incodeinfo
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
View(loadinginfo_linked)
View(incodeinfo)
View(info)
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
incodeinfo
r_file
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
View(info)
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
View(incodeinfo)
# add "monitor" to the info file
incodeinfo[["monitor"]]<- paste0("M", gsub("\\D", "", incodeinfo$file))
#change any NA values to "NA" to prevent errors
incodeinfo[is.na(incodeinfo)] <- "NA"
incodeinfo[,6:11]<- lapply(incodeinfo[,6:11], as.character)
View(incodeinfo)
# add "monitor" to the info file
incodeinfo[["monitor"]]<- paste0("M", gsub("\\D", "", incodeinfo$file))
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
#' @param plotSelection A character string specifying if the user wants all possible plots, no optional plots, or select specific plot outputs.
#' @param font A string variable determining the font style of the produced plots.
#' @param pValues A TRUE/FALSE vector for if combined plots will display p values for 2-condition overlays.
#' @export
#'
#' @return This function does not return a value but performs a series of steps to process the data,
#' generate plots, and calculate statistics.
#'
#'
#' @keywords export
runOneBatch <- function(oneBatch, numDays,
overlayVar = c("Treatment", "Sex", "Genotype", "Temperature", "Environment", "Light"),
rowVar = c("Genotype", "Sex", "Temperature", "Treatment", "Environment", "Light"),
columnVar = c("Environment", "Sex", "Genotype", "Temperature", "Treatment", "Light"),
plotSelection = c("All", "None", "Select"),
font = c("plain", "bold", "italic", "bold.italic"),
pValues = c(FALSE, TRUE)) {
# Warnings/Errors-------------------------------------------------------------
if (missing(oneBatch)){
stop("'oneBatch' must be specified")
}
all_dirs <- list.dirs(getwd(), full.names = FALSE, recursive = FALSE)
if (length(grep(oneBatch, all_dirs)) != 1){
stop("The 'oneBatch' specified is not a subdirectory inside the current working directory. Please make sure your current directory is correct.")
}
if (missing(numDays) || !is.numeric(numDays)){
stop("'numDays' must be specified as a whole number.")
}
if(length(unique(c(overlayVar, rowVar, columnVar))) < 3){  # divisions for fascetting plots
stop("'overlayVar', rowVar, and columnVar cannot contain the same variable names.")
}
divisions<- character()
divisions[1]<- match.arg(overlayVar)
divisions[2]<- match.arg(rowVar)
divisions[3]<- match.arg(columnVar)
plotSelection <- match.arg(plotSelection)
#divisions<- c(overlayVar, rowVar, columnVar)
font<- match.arg(font)
if(!is.logical(pValues)){
stop("'pValues' must be either 'TRUE' or 'FALSE'")
}
# Set the stage---------------------------------------------------------------
# Save the current working directory
original_wd <- getwd()
# Change to the target directory
setwd(paste0(original_wd, "/", oneBatch))
# Get the list of R files in the directory
r_files <- list.files(getwd(), pattern = "^Main[0-9_a-zA-Z]*\\.R$", full.names = TRUE)
# Store all 'info' objects in a list, in case multiple R files exist
all_info_list <- list()
# Execute each R file within a temporary local environment
for (r_file in r_files) {
# 1. Create a new, temporary environment for execution
temp_env <- new.env()
# 2. Execute the script within that environment
source(r_file, local = temp_env)
# 3. Check if 'info' was created and extract it
if (exists("info", envir = temp_env, inherits = FALSE)) {
all_info_list[[r_file]] <- temp_env$info
} else {
warning(paste("Script did not define an 'info' object:", r_file))
}
}
# The single batch code implies only one file or a combination.
# If it's intended to combine them (as in 'runAllBatches'), use rbindlist:
if (length(all_info_list) > 0) {
incodeinfo <- data.table::rbindlist(all_info_list, fill = TRUE)
} else {
stop("No metadata ('info' object) was successfully loaded from the 'Main*.R' file(s).")
}
}
# add "monitor" to the info file
incodeinfo[["monitor"]]<- paste0("M", gsub("\\D", "", incodeinfo$file))
View(incodeinfo)
#change any NA values to "NA" to prevent errors
incodeinfo[is.na(incodeinfo)] <- "NA"
incodeinfo[,6:11]<- lapply(incodeinfo[,6:11], as.character)
