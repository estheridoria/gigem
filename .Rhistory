axis.text.y = ggplot2::element_text(size = 2))+
ggetho::stat_tile_etho()
ggetho::ggetho(data, ggplot2::aes(z = asleep)) +
ggetho::stat_ld_annotations(ypos = "top")
ggetho::ggetho(dt[behavr::xmv(monitor) == i], ggplot2::aes(z=asleep))
ggetho::ggetho(data, ggplot2::aes(z = asleep))
ggetho::ggetho(data, ggplot2::aes(z = asleep)) +
ggetho::stat_ld_annotations(ypos = "top")
?ggetho::stat_ld_annotations
ggetho::ggetho(dt[behavr::xmv(monitor) == i], ggplot2::aes(z=asleep)) +
ggetho::stat_ld_annotations(ypos = "top")
source("~/GitHub/gigem/R/aliveVsDead.R")
# Create activity plots before and after removing "dead", providing list of IDs removed from first trimming
dt_curated <- aliveVsDead(ExperimentData, dt_activity)
dt <- dt_curated
# Remove animals dying too early
lifespan_dt <- dt[, .(lifespan = max(t)), by=id]
valid_ids <- lifespan_dt[lifespan >= behavr::days(num_days), id] ## previously it was stated > not >=
# Apply the filter and ensure it stays a behavr object
filtered_meta <- behavr::meta(dt)[id %in% valid_ids]
dt_curated_2 <- dt[id %in% valid_ids]
dt_curated_2 <- behavr::behavr(dt_curated_2, filtered_meta)
# Identify and save IDs being removed
removed_ids <- setdiff(dt[, id, meta = TRUE], dt_curated_2[, id, meta = TRUE]) # replaced with the line below
curated_2_list <- data.table::data.table(removed_ids)
data.table::fwrite(curated_2_list, paste0("removed_list2_", ExperimentData@Batch, ".csv"))
# Trim data to the desired time range
dt_curated_final <- dt_curated_2[dt_curated_2$t >= behavr::days(0) &
dt_curated_2$t <= behavr::days(num_days)]
# Generate population plots
create_population_plot <- function(filename, plot_data, divisions, numb_days = num_days, wrap_time = NULL) {
pdf(filename, width = 5*numb_days+2,
height = 3*prod(sapply(divisions[1:3], function(col) length(unique(info[[col]]))))+2)
pop_sleep_plot <- ggetho::ggetho(plot_data, ggplot2::aes(y = asleep, colour = .data[[divisions[1]]]), time_wrap = wrap_time) +
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations()+
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[1]),
!!rlang::sym(divisions[2]),
!!rlang::sym(divisions[3])))+
ggplot2::scale_y_continuous(name = "Percentage of flies sleeping", labels = scales::percent)
print(pop_sleep_plot)
dev.off()
}
ggetho::ggetho(plot_data, ggplot2::aes(y = asleep, colour = .data[[divisions[1]]]), time_wrap = wrap_time) +
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations()
# Generate population plots
create_population_plot <- function(filename, plot_data, divisions, numb_days = num_days, wrap_time = NULL) {
pdf(filename, width = 5*numb_days+2,
height = 3*prod(sapply(divisions[1:3], function(col) length(unique(info[[col]]))))+2)
pop_sleep_plot <- ggetho::ggetho(plot_data, ggplot2::aes(y = asleep, colour = .data[[divisions[1]]]), time_wrap = wrap_time) +
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations()+
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[1]),
!!rlang::sym(divisions[2]),
!!rlang::sym(divisions[3])))+
ggplot2::scale_y_continuous(name = "Percentage of flies sleeping", labels = scales::percent)
print(pop_sleep_plot)
dev.off()
}
create_population_plot(paste0(ExperimentData@Batch, '_population_sleep.pdf'), dt_curated_final, divisions)
# Further removal and trimming of animals that died before specified time, providing list of IDs removed
dt_final <- manualDeadRemoval(ExperimentData, dt_curated, num_days, divisions, pref)
source("~/GitHub/gigem/R/manualDeadRemoval.R")
# Further removal and trimming of animals that died before specified time, providing list of IDs removed
dt_final <- manualDeadRemoval(ExperimentData, dt_curated, num_days, divisions, pref)
source("~/GitHub/gigem/R/manualDeadRemoval.R")
# Further removal and trimming of animals that died before specified time, providing list of IDs removed
dt_final <- manualDeadRemoval(ExperimentData, dt_curated, num_days, divisions, pref)
source("~/GitHub/gigem/R/manualDeadRemoval.R")
# Further removal and trimming of animals that died before specified time, providing list of IDs removed
dt_final <- manualDeadRemoval(ExperimentData, dt_curated, num_days, divisions, pref)
# Write bout length pdf, and calculate bout and latency stats
dt_finalSummary <- cleanSummary(ExperimentData, dt_final, num_days, loading_metadata, divisions, pref)
source("~/GitHub/gigem/R/cleanSummary.R")
# Write bout length pdf, and calculate bout and latency stats
dt_finalSummary <- cleanSummary(ExperimentData, dt_final, num_days, loading_metadata, divisions, pref)
source("~/GitHub/gigem/R/processDays.R")
# Write bout length pdf, and calculate bout and latency stats
dt_finalSummary <- cleanSummary(ExperimentData, dt_final, num_days, loading_metadata, divisions, pref)
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
dt_curated_final<-dt_final
summary_dt_final<- dt_finalSummary
# Get unique values for light, environment, and genotype
llist <- unique(summary_dt_final$light)
elist <- unique(summary_dt_final$environment)
glist <- unique(summary_dt_final$genotype)
l=1
e=1
g=1
# Prepare data subset for the specific light, environment, genotype combination
sub_data <- summary_dt_final[light == llist[l] & environment == elist[e] & genotype == glist[g]]
plot_subdata <- dt_curated_final[id %in% sub_data$id]
# Function to create sleep duration plots
create_sleeptime_plot <- function(plot_data, yParam, Yname, limits, geom) {
pointplot<- ggplot2::ggplot(plot_data[light == llist[l] & environment == elist[e] & genotype == glist[g]],
ggplot2::aes(x = treatment, y = .data[[yParam]]))
if(geom == "bar"){
pointplot <- pointplot +
ggplot2::stat_summary(fun = "mean", geom = geom, width = .5, fill="grey90")
}
if(geom == "violin"){
pointplot <- pointplot +
ggplot2::geom_violin(fill="grey90")
}
pointplot <- pointplot +
ggbeeswarm::geom_beeswarm(ggplot2::aes(fill = treatment, color = treatment),
dodge.width = 0.9, shape = 21, cex = 3.5) +
ggplot2::scale_color_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .7)) +
ggplot2::scale_fill_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .6)) +
ggplot2::geom_errorbar(stat = "summary", fun.data = Hmisc::mean_cl_boot, width = 0.2,
color = "black") +
ggplot2::geom_point(size = 1.5, stat = "summary", fun = mean, shape = 3,
color = "black") +
ggprism::theme_prism(base_fontface = "plain", base_line_size = 0.7)  +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust= 1),
plot.margin = ggplot2::margin(0,0,0,0,"inches"), legend.position = "none") +
ggplot2::ylim(0,limits) +
ggplot2::labs(title = "", x = NULL, y = Yname)
return(pointplot)
}
ggplot2::ggplot(plot_data[light == llist[l] & environment == elist[e] & genotype == glist[g]],
ggplot2::aes(x = treatment, y = .data[[yParam]]))
plot_data<- summary_dt_final
yParam <- "sleep_time_all"
Yname <- "Total Sleep (min)"
limits <- 1500
geom = "bar"
ggplot2::ggplot(plot_data[light == llist[l] & environment == elist[e] & genotype == glist[g]],
ggplot2::aes(x = treatment, y = .data[[yParam]]))
pointplot<- ggplot2::ggplot(plot_data[light == llist[l] & environment == elist[e] & genotype == glist[g]],
ggplot2::aes(x = treatment, y = .data[[yParam]]))
if(geom == "bar"){
pointplot <- pointplot +
ggplot2::stat_summary(fun = "mean", geom = geom, width = .5, fill="grey90")
}
pointplot +
ggplot2::stat_summary(fun = "mean", geom = geom, width = .5, fill="grey90")
pointplot +
ggbeeswarm::geom_beeswarm(ggplot2::aes(fill = treatment, color = treatment),
dodge.width = 0.9, shape = 21, cex = 3.5) +
ggplot2::scale_color_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .7)) +
ggplot2::scale_fill_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .6))
hist(plot_data)
View(plot_data)
hist(plot_data$sleep_time_all[light == llist[l] & environment == elist[e] & genotype == glist[g]])
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
g<-2
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
g<-3
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
g<-4
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
g<-5
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
g<-6
hist(plot_data$sleep_time_all[plot_data$light == llist[l] & plot_data$environment == elist[e] & plot_data$genotype == glist[g]])
pointplot +
ggbeeswarm::geom_beeswarm(ggplot2::aes(fill = treatment, color = treatment),
dodge.width = 0.9, shape = 21, cex = 3.5) +
ggplot2::scale_color_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .7)) +
ggplot2::scale_fill_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .6)) +
ggplot2::geom_errorbar(stat = "summary", fun.data = ggplot2::mean_cl_boot(), width = 0.2,
color = "black") +
ggplot2::geom_point(size = 1.5, stat = "summary", fun = mean, shape = 3,
color = "black") +
ggprism::theme_prism(base_fontface = "plain", base_line_size = 0.7)  +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust= 1),
plot.margin = ggplot2::margin(0,0,0,0,"inches"), legend.position = "none") +
ggplot2::ylim(0,limits) +
ggplot2::labs(title = "", x = NULL, y = Yname)
pointplot +
ggbeeswarm::geom_beeswarm(ggplot2::aes(fill = treatment, color = treatment),
dodge.width = 0.9, shape = 21, cex = 3.5) +
ggplot2::scale_color_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .7)) +
ggplot2::scale_fill_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .6)) +
ggplot2::geom_errorbar(stat = "summary", fun.data = ggplot2::mean_cl_boot, width = 0.2,
color = "black") +
ggplot2::geom_point(size = 1.5, stat = "summary", fun = mean, shape = 3,
color = "black") +
ggprism::theme_prism(base_fontface = "plain", base_line_size = 0.7)  +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust= 1),
plot.margin = ggplot2::margin(0,0,0,0,"inches"), legend.position = "none") +
ggplot2::ylim(0,limits) +
ggplot2::labs(title = "", x = NULL, y = Yname)
return(pointplot)
# Function to create sleep duration plots
create_sleeptime_plot <- function(plot_data, yParam, Yname, limits, geom) {
pointplot<- ggplot2::ggplot(plot_data[light == llist[l] & environment == elist[e] & genotype == glist[g]],
ggplot2::aes(x = treatment, y = .data[[yParam]]))
if(geom == "bar"){
pointplot <- pointplot +
ggplot2::stat_summary(fun = "mean", geom = geom, width = .5, fill="grey90")
}
if(geom == "violin"){
pointplot <- pointplot +
ggplot2::geom_violin(fill="grey90")
}
pointplot <- pointplot +
ggbeeswarm::geom_beeswarm(ggplot2::aes(fill = treatment, color = treatment),
dodge.width = 0.9, shape = 21, cex = 3.5) +
ggplot2::scale_color_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .7)) +
ggplot2::scale_fill_manual(values = scales::alpha(c("blue", "red", "purple", "pink"), alpha = .6)) +
ggplot2::geom_errorbar(stat = "summary", fun.data = ggplot2::mean_cl_boot, width = 0.2,
color = "black") +
ggplot2::geom_point(size = 1.5, stat = "summary", fun = mean, shape = 3,
color = "black") +
ggprism::theme_prism(base_fontface = "plain", base_line_size = 0.7)  +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust= 1),
plot.margin = ggplot2::margin(0,0,0,0,"inches"), legend.position = "none") +
ggplot2::ylim(0,limits) +
ggplot2::labs(title = "", x = NULL, y = Yname)
return(pointplot)
}
# Generate sleep duration plots
p2 <- create_sleeptime_plot(summary_dt_final, "sleep_time_all", "Total Sleep (min)", 1500, "bar")
View(p2)
plot(p2)
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
# Create overlay sleep plot
p1 <- ggetho::ggetho(plot_subdata, ggplot2::aes(y = asleep, colour = treatment), time_wrap = behavr::hours(24)) +
ggetho::stat_pop_etho(show.legend = T) +
ggetho::stat_ld_annotations() +
ggplot2::scale_color_manual(values = c("blue", "red", "purple", "pink")) +
ggplot2::scale_fill_manual(values = c("blue", "red", "purple", "pink")) +
ggprism::theme_prism(base_fontface = "plain", base_line_size = 0.7) +
ggplot2::theme(legend.position.inside = c(0.80, 0.15))+
ggplot2::labs(title = glist[g], y= "Percentage of flies sleeping") +
ggplot2::scale_y_continuous(limits = c(0,1), labels = scales::percent)
suppressWarnings(
combined_plot <- cowplot::plot_grid(p1, p2, p3, p4, p5, p6, ncol = 6, align = "h", axis = "b",
rel_widths = c(6, u, u, u, u, u)))
source("~/GitHub/gigem/R/genotypePlots.R")
# Generate concatenated plots
genotypePlots(dt_final, dt_finalSummary)
# Define input column names for normalized statistics
groups <- c("sleep_time_all",
"sleep_time_l",
"sleep_time_d",
"n_bouts_L",
"mean_bout_length_L",
"n_bouts_D",
"mean_bout_length_D")
# Calculate the normalization factor for statistics
norm_factor <- dt_finalSummary[, lapply(.SD, mean),
by = .(genotype, treatment),
.SDcols = groups]
# Summary of statistics for sleep time for all groups
stat_summary <- statsSummary(ExperimentData, dt_finalSummary, groups, norm_factor)
source("~/GitHub/gigem/R/statsSummary.R")
# Summary of statistics for sleep time for all groups
stat_summary <- statsSummary(ExperimentData, dt_finalSummary, groups, norm_factor)
source("~/GitHub/gigem/R/summarySE.R")
source("~/GitHub/gigem/R/generateNorms.R")
source("~/GitHub/gigem/R/generateSE.R")
# Summary of statistics for sleep time for all groups
stat_summary <- statsSummary(ExperimentData, dt_finalSummary, groups, norm_factor)
# Calculate normalized statistics of sleep time for all groups
norm_summary <- normSummary(ExperimentData, dt_finalSummary, groups, norm_factor, controlgeno, controltreat)
source("~/GitHub/gigem/R/normSummary.R")
# Calculate normalized statistics of sleep time for all groups
norm_summary <- normSummary(ExperimentData, dt_finalSummary, groups, norm_factor, controlgeno, controltreat)
source("~/GitHub/gigem/R/runAllBatches.R")
source("~/GitHub/gigem/R/runOneBatch.R")
source("~/GitHub/gigem/R/zzz.R")
source("~/GitHub/gigem/R/writeLoading.R")
source("~/GitHub/gigem/R/summarySE.R")
source("~/GitHub/gigem/R/statsSummary.R")
source("~/GitHub/gigem/R/setStatus.R")
source("~/GitHub/gigem/R/runOneBatch.R")
source("~/GitHub/gigem/R/runAllBatches.R")
source("~/GitHub/gigem/R/processDays.R")
source("~/GitHub/gigem/R/plotPreferences.R")
source("~/GitHub/gigem/R/normSummary.R")
source("~/GitHub/gigem/R/normDisplay.R")
source("~/GitHub/gigem/R/manualDeadRemoval.R")
source("~/GitHub/gigem/R/kmeansCluster.R")
source("~/GitHub/gigem/R/genotypePlots.R")
source("~/GitHub/gigem/R/generateSE.R")
source("~/GitHub/gigem/R/generateNorms.R")
source("~/GitHub/gigem/R/corMat.R")
source("~/GitHub/gigem/R/concatenate.R")
source("~/GitHub/gigem/R/cleanSummary.R")
source("~/GitHub/gigem/R/aliveVsDead.R")
source("~/GitHub/gigem/R/activityAndSleep.R")
if (!methods::isClass("ExperimentData")) {
# Define the ExperimentData class to store information
if (!methods::isClass("data.table")) {
methods::setClass("data.table", contains = "data.frame")
}
methods::setClass(
Class = "ExperimentData",
slots = list(
Batch = "character",
monitorlist = "list",
genotypelist = "list",
loadinginfo = "data.table"
)
)
}
parent_dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(parent_dir)
# Determine which variables to divide the plots by:
# (e.g. temp, sex, genotype, treatment, environment, or light)
divisions<- c("treatment",            # 1: Sleep plot, overlay and color
"sex",                  # 2: Sleep plot, rows
"genotype",             # 3: Sleep plot, columns
"treatment",            # 4: Point plot, x-axis and color
"sex",                  # 3: Point plot, rows
"genotype")             # 6: Point plot, columns
# Set the number of days you wish to analyze
num_days = 2
# Run the Analysis
runAllBatches(controlgeno = "CS", controltreat = "Grp")
warnings()
#ask user which plots they want
pref <- plotPreferences()
# Get the list of all sub directories
all_dirs <- list.dirs(parent_dir, full.names = TRUE, recursive = FALSE)
# Save the current working directory
original_wd <- getwd()
run_r_files_in_dir <- function(dir) {
# Change to the target directory
setwd(dir)
# Get the list of R files in the directory
r_files <- list.files(dir, pattern = "\\.R$", full.names = TRUE)
# Source each R file
for (r_file in r_files) {
source(r_file) # should I take this out? and reformat it to remove source()?
}
}
# Filter directories that match the "Batch" pattern.
batch_dirs <- grep("Batch[0-9_a-zA-Z]*", all_dirs, value = TRUE)
batch_dir <- batch_dirs[1]
run_r_files_in_dir(batch_dir)
runOneBatch(info, divisions, num_days, pref, controlgeno, controltreat)
run_r_files_in_dir(batch_dir)
runOneBatch(info, divisions, num_days, pref, controlgeno, controltreat)
# Create an object that contains all of your inputs
ExperimentData <- new("ExperimentData",
Batch = Title,
monitorlist = as.list(unique(info$monitor)),
genotypelist = as.list(unique(info$genotype)),
loadinginfo = info)
# Store this as a CSV file, used to curate summary tables
loading_metadata <- writeLoading(ExperimentData)
# Create activity plots and sleep plots of each monitor at time t
dt_activity <- activityAndSleep(ExperimentData, loading_metadata, pref)
# Create activity plots before and after removing "dead", providing list of IDs removed from first trimming
dt_curated <- aliveVsDead(ExperimentData, dt_activity)
# Further removal and trimming of animals that died before specified time, providing list of IDs removed
dt_final <- manualDeadRemoval(ExperimentData, dt_curated, num_days, divisions, pref)
# Write bout length pdf, and calculate bout and latency stats
dt_finalSummary <- cleanSummary(ExperimentData, dt_final, num_days, loading_metadata, divisions, pref)
dt <-
dt_final
loadinginfo_linked <- loading_metadata
# day night sleep calculation using modulo operation,
dt[, phase := ifelse(t %% behavr::hours(24) < behavr::hours(12), "L", "D")]
# Calculate overall sleep metrics and phase-based sleep data
summary_dt_final <- behavr::rejoin(dt[, .(
sleep_fraction = mean(asleep),
sleep_fraction_all = mean(asleep),
sleep_time_all = 1440 * mean(asleep),
sleep_fraction_l = mean(asleep[phase == "L"]),
sleep_time_l = 720 * mean(asleep[phase == "L"]),
sleep_fraction_d = mean(asleep[phase == "D"]),
sleep_time_d = 720 * mean(asleep[phase == "D"])
), by = id])
# Remove the 'file_info' column
summary_dt_final <- summary_dt_final[, file_info := NULL]
# Perform bout analysis for sleep architecture
bout_dt <- sleepr::bout_analysis(asleep, dt)[asleep == TRUE, -"asleep"]
if(pref[6] == 1){
# Plot bout duration by time of day
pdf(paste0(ExperimentData@Batch, '_population_sleep_bout_wrap', '.pdf'),
width = 5*length(unique(info[[divisions[3]]]))+2,
height = 3*length(unique(info[[divisions[2]]]))+2)
print(
ggetho::ggetho(bout_dt, ggplot2::aes(y = duration / 60, colour = treatment), time_wrap = behavr::hours(24)) +
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations() +
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[2])),
cols = ggplot2::vars(!!rlang::sym(divisions[3]))) +
ggplot2::scale_y_continuous(name = "Bout length (min)")
)
dev.off()
}
if(pref[6] == 1){
# Plot bout duration by time of day
pdf(paste0(ExperimentData@Batch, '_population_sleep_bout_wrap', '.pdf'),
width = 5*length(unique(info[[divisions[3]]]))+2,
height = 3*length(unique(info[[divisions[2]]]))+2)
print(
supress.Warnings(
ggetho::ggetho(bout_dt, ggplot2::aes(y = duration / 60, colour = treatment), time_wrap = behavr::hours(24)) +
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations() +
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[2])),
cols = ggplot2::vars(!!rlang::sym(divisions[3]))) +
ggplot2::scale_y_continuous(name = "Bout length (min)")
)
)
dev.off()
}
if(pref[6] == 1){
# Plot bout duration by time of day
pdf(paste0(ExperimentData@Batch, '_population_sleep_bout_wrap', '.pdf'),
width = 5*length(unique(info[[divisions[3]]]))+2,
height = 3*length(unique(info[[divisions[2]]]))+2)
print(
suppress.Warnings(
ggetho::ggetho(bout_dt, ggplot2::aes(y = duration / 60, colour = treatment), time_wrap = behavr::hours(24)) +
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations() +
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[2])),
cols = ggplot2::vars(!!rlang::sym(divisions[3]))) +
ggplot2::scale_y_continuous(name = "Bout length (min)")
)
)
dev.off()
}
if(pref[6] == 1){
# Plot bout duration by time of day
pdf(paste0(ExperimentData@Batch, '_population_sleep_bout_wrap', '.pdf'),
width = 5*length(unique(info[[divisions[3]]]))+2,
height = 3*length(unique(info[[divisions[2]]]))+2)
print(
suppressWarnings(
ggetho::ggetho(bout_dt, ggplot2::aes(y = duration / 60, colour = treatment), time_wrap = behavr::hours(24)) +
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations() +
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[2])),
cols = ggplot2::vars(!!rlang::sym(divisions[3]))) +
ggplot2::scale_y_continuous(name = "Bout length (min)")
)
)
dev.off()
}
# Plot bout duration by time of day
pdf(paste0(ExperimentData@Batch, '_population_sleep_bout_wrap', '.pdf'),
width = 5*length(unique(info[[divisions[3]]]))+2,
height = 3*length(unique(info[[divisions[2]]]))+2)
suppressWarnings(print(
ggetho::ggetho(bout_dt, ggplot2::aes(y = duration / 60, colour = treatment), time_wrap = behavr::hours(24)) +
ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = "white"),
strip.background = ggplot2::element_rect(fill="white"),
plot.margin = ggplot2::margin(1,1,1,1,"inches"))+
ggetho::stat_pop_etho() +
ggetho::stat_ld_annotations() +
ggplot2::facet_grid(rows = ggplot2::vars(!!rlang::sym(divisions[2])),
cols = ggplot2::vars(!!rlang::sym(divisions[3]))) +
ggplot2::scale_y_continuous(name = "Bout length (min)")
)
)
dev.off()
source("~/GitHub/gigem/R/cleanSummary.R")
# Write bout length pdf, and calculate bout and latency stats
dt_finalSummary <- cleanSummary(ExperimentData, dt_final, num_days, loading_metadata, divisions, pref)
??install_github
knitr::opts_chunk$set(echo = FALSE)
build()
library(devtools)
build()
library(gigem)
build()
usethis::create_package("C:/Users/Wanhe/OneDrive/Documents/GitHub/gigem")
setwd(E:C.SIP_Data/gigem)
setwd(E:/C.SIP_Data/gigem)
setwd("E:/C.SIP_Data/gigem")
devtools::document()
usethis::create_package()
usethis::create_package("E:/C. SIP_Data/gigem")
usethis::create_package("E:/C.SIP_Data/gigem")
devtools::document()
devtools::install("E:/C.SIP_Data/gigem")
devtools::install("E:/C.SIP_Data/gigem")
